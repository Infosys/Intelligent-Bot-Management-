$ParseToStringItemHardCoded
	        // Append ##Value## value for data item ##ItemName##
            sb.Append(Pad(##Value##,##ItemLength##, "##PadString##", ##IsStringType##));
$ParseToStringSignedType
			// Append single space for a positive valued signed type variable
            if(dataEntity.##DataEntityClass##sCollection[itemLooper].##DataItemName## > 0 )
            {
                sb.Append(" ");
            }
            // Append '-' for a negatived valued signed type variable
            else
            {
                sb.Append("-");
            }
$ParseToStringItem
            // Check whether the length of the string after padding is greater than 
            // the length acceptable to the host
            if(dataEntity.##DataItemName##.ToString().Length > ##DataItemLength##)
            {
                throw new Exception("The length of ##DataItemName## is greater than expected value");
            }
            //Appending ##DataItemName## string type
            sb.Append(Pad(dataEntity.##DataItemName##, ##DataItemLength##, "##PadItem##", ##IsStringType##));            
$end

$ParseToStringCollectionItem
			// Check whether the length of the string after padding is greater than 
            // the length acceptable to the host
            if (dataEntity.##DataItemName##Collection.Count > 0)
            {
                for (int occurIndex = 0; occurIndex < ##Occurance##; occurIndex++)
                {
                    if (dataEntity.##DataItemName##Collection[occurIndex].ToString().Length > ##DataItemLength##)
                    {
                        throw new Exception("The length of ##DataItemName##Collection[occurIndex] is greater than expected value");
                    }
                }
            }

            //Appending ##DataItemName##Collection string type
            if (dataEntity.##DataItemName##Collection.Count > 0)
            {
                for (int occurIndex = 0; occurIndex < ##Occurance##; occurIndex++)
                {
                    sb.Append(Pad(dataEntity.##DataItemName##Collection[occurIndex].ToString(), ##DataItemLength##, "##PadItem##", ##IsStringType##));
                }
            }            
$end

$ParseToStringItemEnum
            //decide the item which has to be placed according to the value of the Enum
		    switch(dataEntity.##DataEntityClass##sCollection[itemLooper].##DataItemName##)
		    {
    			##ParseToStringItemEnumCases##
	    	}
$end
$ParseToStringItemEnumCase
			    case DataEntity.##EnumName##.##EnumTypeName##:
                    //Append the appropriate string type
				    sb.Append("##EnumValue##");
				    break;
$ParseToEntityInt
                //Retrieve the appropriate integer type from location ##Position##, length of ##Length##
                dataEntity.##DataItemName## = Convert.ToInt32(parseString.Substring(##Position##, ##Length##));

$ParseToEntityString
                //Retrieve the appropriate string type from location ##Position##, length of ##Length##
                dataEntity.##DataItemName## = parseString.Substring(##Position##, ##Length##);
$ParseToEntityHardCoded
                // Assign the value which has been declared to be returned everytime.
                dataEntity.##ItemName## = ##Value##;
$ParseToEntityCollectionItem
				//Retrieve the appropriate string type from location ##Position##, length of ##Length##
                lengthCounter = 0;
                for (int occurIndex = 0; occurIndex < ##Occurance##; occurIndex++)
                {
                    dataEntity.##DataItemName##Collection.Add(parseString.Substring(##Position## + lengthCounter, ##Length##));
                    lengthCounter += ##Length##;
                }
$end
using System;
using System.Text;

//Import the model object data entity namespace
using DataEntity = ##DataEntityNameSpace##;

//Import LIF framework namespaces
using Infosys.Lif.LegacyParser.Framework;
using Infosys.Lif.LegacyParameters;

/******************************************************************************
 This parser class was code generated by Legacy Workbench.
 
 This is model object serializer class for the host object ##ObjectId##
 
 Copyright (c) 2003 - 2008 Infosys Technologies Ltd. All Rights Reserved.
******************************************************************************/

namespace ##Namespace##
{
    /// <summary>
    /// This is a serializer class for model object ##ObjectId##.
    /// This class is used to serialize the data entity to ASCII string and vice versa
    /// </summary>
    public class ##ClassName## : SerializerBase
    {        
        /// <summary>
        /// The Serialize method is used to serialize a Data Entity
        /// The items in the Data Entity will be appended to form an ascii string.
        /// </summary>
        /// <param name="dataEntityObj">The Data Entity of type ##DataEntityClass## which has to be serialized</param>
        /// <returns>The serialized ASCII string</returns>
        public override string Serialize(object dataEntityObj)
        {
			//model object data entity which is to be serialized
         	DataEntity.##DataEntityClass## dataEntity = 
                (DataEntity.##DataEntityClass##)dataEntityObj;                
           
            //prepare a string builder to hold the serialized ASCII string.
            StringBuilder sb = new StringBuilder();            
            
            ##ParseToString##            

            //return the string built.
            return sb.ToString();		    
        }
        
        /// <summary>
        /// The Deserialize method is used to deserialize an ascii string to its Data Entity
        /// </summary>
        /// <param name="parseString">The string which has to be deserialized.</param>
        /// <returns>Deserialized DataEntity i.e. Clientpolicyinfo object containing the values 
        /// as returned by the host through the input ascii string</returns>
        public override object Deserialize(string parseString)
        {
            //Create an object which can be returned.
    	    DataEntity.##DataEntityClass## dataEntity = new DataEntity.##DataEntityClass##();
            
            // The number of records sent in the ascii string.
    	    int numberOfRecords = Convert.ToInt32(parseString.Substring(5, 5));
    	    
            // The length of each record in the string.
            int lengthOfEachRecord = Convert.ToInt32(parseString.Substring(10, 5));
            
            //The first 33 characters is the header indicating the correctness of the data retireved.
            // and errors, if any.
            parseString = parseString.Substring(33);

            if(parseString.Length < numberOfRecords * lengthOfEachRecord)
            {
                throw new Exception("Length of string received by ##DataEntityClass## de-serializer is incorrect.");
            }
            
            //Build the Data Entity
            for(int entityCounter = 0; entityCounter < numberOfRecords; entityCounter++)
            {                
                //Parse the string
                int lengthCounter;
                
                ##ParseToEntity##
                
                //Substring the input string so that the next record can be parsed.
                parseString = parseString.Substring(lengthOfEachRecord);
            }
            
            //return deserialized data entity with data returned from the host.
            return dataEntity;
        }
    }
}

