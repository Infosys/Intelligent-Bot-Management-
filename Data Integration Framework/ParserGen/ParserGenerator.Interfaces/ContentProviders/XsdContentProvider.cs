using System;
using System.Collections.Generic;
using System.Text;

// Infosys Code Generator v1.1
using Infosys.Solutions.CodeGeneration.Framework;

/****************************************************************
 * This file is a part of the Legacy Parser utility.
 * This class is used to retrieve the content for the XSD template.
 * Copyright (c) 2003 - 2005 Infosys Technologies Ltd. All Rights Reserved.
 * ***************************************************************/

namespace Infosys.Lif.LegacyParser.ContentProviders
{
    #region XsdContentProvider definition
    /// <summary>
    /// Objects of this type are used to generate content for the 
    /// XSD for a Data Entity.
    /// </summary>
    public class XsdContentProvider : ContentProvider
    {
        /// <summary>
        /// The entity for which the XSD is being gnerated.
        /// </summary>
        private Entity entityToBeUsed;

        /// <summary>
        /// The public constructor for this type.
        /// </summary>
        /// <param name="entityToBeBuilt">
        /// The entity for which this XSD file has to be generated.
        /// </param>
        public XsdContentProvider(Entity entityToBeBuilt)
        {
            entityToBeUsed = entityToBeBuilt;
        }

        /// <summary>
        /// The name of the entity.
        /// </summary>
        [PlaceHolder("DataEntityName")]
        private string DataEntityName
        {
            get
            {
                return entityToBeUsed.DataEntityClassName;
            }
        }

        /// <summary>
        /// The items of this entity for which the code should be generated.
        /// This code is generated by this property.
        /// </summary>
        [PlaceHolder("DataItems")]
        private string DataItems
        {
            get
            {
                return BuildDataItems(entityToBeUsed.DataItems);
            }
        }

        private string BuildDataItems(GenericCollection<DataItem> genericCollection)
        {
            string strFilled = string.Empty;
            for (int itemLooper = 0; itemLooper < genericCollection.Count;
    itemLooper++)
            {
                DataItem currItem = genericCollection[itemLooper];
                if (currItem.IsVisible)
                {
                    if (currItem.ItemType == DataItem.DataItemType.GroupItemType)
                    {
                        strFilled += BuildDataItems(currItem.GroupItems);
                    }
                    else if (currItem.ItemType == DataItem.DataItemType.EnumType && currItem.Length > 0)
                    {
                        EnumType enumObject = null;
                        foreach (EnumType enumeration in entityToBeUsed.Enums)
                        {
                            if (enumeration.Name == currItem.EnumName)
                            {
                                enumObject = enumeration;
                                break;
                            }
                        }
                        if (enumObject != null)
                        {
                            DataItemEnumType dataItemContentProvider
                                = new DataItemEnumType(currItem, enumObject);
                            dataItemContentProvider.DataItemPropertyTemplate =
                                ContentTemplate.RepeatingTemplate(
                                DataItemProperty.ProvidesContentFor);
                            dataItemContentProvider.ContentTemplate
                                = ContentTemplate.RepeatingTemplate(
                                DataItemEnumType.ProvidesContentFor);
                            strFilled += dataItemContentProvider.GenerateContent();
                        }

                    }
                    else if (currItem.Length > 0)
                    {
                        DataItemContent dataItemContentProvider
                            = new DataItemContent(currItem);
                        dataItemContentProvider.ContentTemplate
                            = ContentTemplate.RepeatingTemplate(DataItemContent.ProvidesContentFor);
                        strFilled += dataItemContentProvider.GenerateContent();
                    }
                }
            }
            return strFilled;
        }
    }
    #endregion

    #region DataItemEnumType definition
    internal class DataItemEnumType : ContentProvider
    {
        internal const string ProvidesContentFor = "DataItemEnumType";
        DataItem enumItem;
        EnumType enumObject;
        internal Template DataItemPropertyTemplate;

        internal DataItemEnumType(DataItem enumTypeItem, EnumType enumDefinitionObject)
        {
            enumItem = enumTypeItem;
            enumObject = enumDefinitionObject;
        }
        [PlaceHolder("Name")]
        internal string Name
        {
            get
            {
                return enumItem.ItemName;
            }
        }

        [PlaceHolder("DataItemProperties")]
        internal string DataItemProperties
        {
            get
            {
                string fillerString = string.Empty;
                for (int enumDefinitionCounter = 0;
                    enumDefinitionCounter < enumObject.EnumProperties.Count;
                    enumDefinitionCounter++)
                {
                    DataItemProperty propertyFiller = new DataItemProperty();
                    propertyFiller.PropertyName = enumObject.EnumProperties[enumDefinitionCounter].Name;
                    propertyFiller.ContentTemplate = DataItemPropertyTemplate;
                    fillerString += propertyFiller.GenerateContent();
                }
                return fillerString;
            }
        }
    }

    #endregion

    #region DataItemProperty definition
    internal class DataItemProperty : ContentProvider
    {
        internal const string ProvidesContentFor = "DataItemProperty";
        string _propertyName = " ";

        [PlaceHolder("PropertyName")]
        internal string PropertyName
        {
            get { return _propertyName; }
            set { _propertyName = value; }
        }

    }
    #endregion

    #region DataItemContent definition
    internal class DataItemContent : ContentProvider
    {
        internal const string ProvidesContentFor = "DataItem";
        string _name = " ";
        DataItem.DataItemType _type;
        public DataItemContent(DataItem itemToBeProvided)
        {
            _name = itemToBeProvided.ItemName;
            _type = itemToBeProvided.ItemType;
            _collectionLength = itemToBeProvided.NumberOfOccurences;
        }
        [PlaceHolder("Name")]
        public string Name
        {
            get
            {
                return _name;
            }
        }
        [PlaceHolder("Type")]
        public string Type
        {
            get
            {
                switch (_type)
                {
                    case DataItem.DataItemType.UnsignedIntegerType:
                        return "int";
                    case DataItem.DataItemType.SignedIntegerType:
                        return "int";
                    case DataItem.DataItemType.StringType:
                        return "string";
                    default:
                        return "string";
                }
            }
        }

        int _collectionLength = 1;
        [PlaceHolder("CollectionLength")]
        public string CollectionLength
        {
            get
            {
                return _collectionLength.ToString();
            }
        }
    }
    #endregion
}
