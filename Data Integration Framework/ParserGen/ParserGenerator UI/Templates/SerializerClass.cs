$ParseToStringItemHardCoded
	        // Append ##Value## value for data item ##ItemName##
            sb.Append(Pad(##Value##,##ItemLength##, "##PadString##", ##IsStringType##));
$ParseToStringSignedType
            if(dataEntity.##DataEntityClass##sCollection[itemLooper].##DataItemName## > 0 )
            {
                sb.Append(" ");
            }
            else
            {
                sb.Append("-");
            }
$ParseToStringItem
            // Check whether the length of the string after padding is greater than 
            // the length acceptable to mainframe
            if(dataEntity.##DataEntityClass##sCollection[itemLooper].##DataItemName##.ToString().Length > ##DataItemLength##)
            {
                throw new Exception("The length of ##DataItemName## is greater than expected value");
            }
            //Appending ##DataItemName## string type
            sb.Append(Pad(dataEntity.##DataEntityClass##sCollection[itemLooper].##DataItemName##, ##DataItemLength##, "##PadItem##", ##IsStringType##));
            
$end
$ParseToStringItemEnum
            //decide the item which has to be placed according to the value of the Enum
		    switch(dataEntity.##DataEntityClass##sCollection[itemLooper].##DataItemName##)
		    {
    			##ParseToStringItemEnumCases##
	    	}
$end
$ParseToStringItemEnumCase
			    case DataEntity.##EnumName##.##EnumTypeName##:
                    //Append the appropriate string type
				    sb.Append("##EnumValue##");
				    break;
$ParseToEntityInt
                //Retrieve the appropriate integer type from location ##Position##, length of ##Length##
                currEntity.##DataItemName## = Convert.ToInt32(parseString.Substring(##Position##, ##Length##));

$ParseToEntityString
                //Retrieve the appropriate string type from location ##Position##, length of ##Length##
                currEntity.##DataItemName## = parseString.Substring(##Position##, ##Length##);
$ParseToEntityHardCoded
                // Assign the value which has been declared to be returned everytime.
                currEntity.##ItemName## = ##Value##;
$end
using System;
using System.Text;
//Include the DataEntity NameSpace
using DataEntity = ##DataEntityNameSpace##.##DataEntityClass##;
using Infosys.Lif.LegacyParser.Framework;
using Infosys.Lif.LegacyParameters;

/**************************************************************************
 * This parser class was code generated by 
 * The Parser Generator tool.
 * It has been genearated for the mainframe object ##ObjectId##
 * Copyright (c) 2003 - 2005 Infosys Technologies Ltd. All Rights Reserved.
**************************************************************************/

namespace ##Namespace##
{
    /// <summary>
    /// The parser class  for Object ##ObjectId##.
    /// This class will be used to serialize the Data Entity to ascii text
    /// or ascii text to Data Entity
    /// </summary>
    public class ##ClassName## : SerializerBase
    {

        /// <summary>
        /// The Data Entity after serialization will give out an 
        /// ascii string of this length
        /// </summary>
        const int LengthOfOneDataString = ##LengthOfDataEntity##;


        /// <summary>
        /// The ParseToString method is used to serialize a Data Entity
        /// The items in the Data Entity will be appended to form an ascii string.
        /// </summary>
        /// <param name="dataEntityObj">The Data Entity of type ##DataEntityClass## which has to be serialized.</param>
        /// <returns>The serialized ascii string.</returns>
        public override string ParseToString(object dataEntityObj)
        {

            // Checking that the data entity passed is not a null and is of the right type.
            // If not, throw an exception
		    if(dataEntityObj == null || 
                dataEntityObj.GetType() != typeof(DataEntity.##DataEntityClass##))
            {
			    throw new Exception("Incorrect data entity passed");
            }
    		DataEntity.##DataEntityClass## dataEntity = 
                (DataEntity.##DataEntityClass##)dataEntityObj;
            if(dataEntity.##DataEntityClass##sCollection == null)
            {
                throw new Exception("##DataEntityClass##.##DataEntityClass##sCollection is null");
            }

            //prepare a string builder with the right capacity
            //41 is the length of the header.
		    StringBuilder sb = new StringBuilder(41 + LengthOfOneDataString * dataEntity.##DataEntityClass##sCollection.Count);
            
            //Start by appending the object id.
		    sb.Append(Pad("##ObjectId##", 8, " ", true));
            
            //This is the index and will be utilized to denote the index of the object
            //Has to be modified according to the number of objects being sent to the host.
            sb.Append("0000");
            
            if(Parameters == null || Parameters.RequestCollection == null
                || Parameters.RequestCollection["OperationType"] == null)
            {
                throw new Exception("Operation type not specified");
            }
            //The type of operation being performed for this mainframe object.
            sb.Append(Parameters.RequestCollection["OperationType"]);
            
            //Append the number of items in this object
            sb.Append(
                Pad(
                dataEntity.##DataEntityClass##sCollection.Count,
                5, "0", false)
                );
            //Append the length of the items in this object
            sb.Append(
                Pad(
                    LengthOfOneDataString, 5, "0", false));

            //The next 18 characters should be blank, and is utilized 
            //to retrieve the return value of the mainframe data.
            sb.Append(Pad(string.Empty, 18, " ", true));
            
            //Loop each item in the Data Entity and prepare the string.
            for(int itemLooper = 0; itemLooper < dataEntity.##DataEntityClass##sCollection.Count;
                itemLooper++)
            {
                ##ParseToString##
            }

            //return the string built.
            return sb.ToString();		    
        }
        /// <summary>
        /// The ParseToDataEntity method is used to de-serialize an ascii string to its Data Entity
        /// </summary>
        /// <param name="parseString">The string which has to be de-serialized.</param>
        /// <returns>De-serialized DataEntity.##DataEntityClass## object containing the values as returned by the mainframe through the input ascii string</returns>
        public override object ParseToDataEntity(string parseString)
        {
            //Create an object which can be returned.
    	    DataEntity.##DataEntityClass## dataEntity = new DataEntity.##DataEntityClass##();
            //Create the collection of items which has to be returned.
    	    dataEntity.##DataEntityClass##sCollection=new DataEntity.##DataEntityClass##sCollection();
            // The number of records sent in the ascii string.
    	    int numberOfRecords = Convert.ToInt32(parseString.Substring(18, 5));
            // The length of each record in the string.
            int lengthOfEachRecord = Convert.ToInt32(parseString.Substring(13, 5));
            
            //The first 41 characters is the header indicating the correctness of the data retireved.
            // and errors, if any.
            parseString = parseString.Substring(41);

            if(parseString.Length < numberOfRecords * lengthOfEachRecord)
            {
                throw new Exception("Length of string received by ##DataEntityClass## de-serializer is incorrect.");
            }
            
            //Build the Data Entity
            for(int entityCounter = 0; entityCounter < numberOfRecords; entityCounter++)
            {
                DataEntity.##DataEntityClass##s currEntity = new DataEntity.##DataEntityClass##s();
                dataEntity.##DataEntityClass##sCollection.Add(currEntity);
                
                //Parse the string
                ##ParseToEntity##
                //Substrin the input string so that the next record can be parsed.
                parseString = parseString.Substring(lengthOfEachRecord);
            }
            return dataEntity;
        }
    }
}

